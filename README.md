# php2-lessons
Интенсив «PHP-2: профессиональное программирование»

#1. Модели данных и ООП
В качестве основы своего проекта возьмите то, что сделано нами на уроке. Ссылка на репозиторий - кнопка "Методические материалы"
Улучшите класс Db. Сейчас мы не имеем с вами возможности передать подстановки в подготовленный SQL-запрос. Добавьте к методам execute() и query() еще по одному аргументу - массив подстановок, по умолчанию пустой. Протестируйте работу новых методов, для чего заведите в проекте папку tests и в ней размещайте скрипты, которые наглядно докажут работоспособность вашего кода.
В абстрактной модели добавьте метод public static findById($id). Он должен вернуть ОДНУ запись из таблицы данной модели, с указанным первичным ключом. Или false, если таковой записи не нашлось.
Сделайте таблицу новостей. Добавьте в нее 3-4 новости. На главной странице сайта (index.php) сделайте вывод 3 последних новостей. Используйте модель News для получения данных (возможно, вам придется добавить какой-то еще метод в эту модель). Для передачи данных в шаблон - просто include файла с шаблоном.
Каждая новость на главной странице должна быть снабжена ссылкой на страницу article.php?id=NNN, где NNN - номер этой новости. Разработайте полностью страницу article.php

#2. Продолжение разговора о моделях
Добавьте в свое приложение класс App\Config. Сделайте его синглтоном. 
Объект этого класса при создании должен читать и сохранять в себе файл конфигурации. Его применение:
$config = App\Config::instance();
echo $config->data['db']['host'];
// пусть это пока коряво смотрится, но по-другому мы еще не умеем
Перенесите к себе метод моделей insert().
Добавьте в метод insert() запись в поле id модели полученного при вставке в таблицу значения поля авто-инкремента.
Продумайте и реализуйте метод update(). Его задача - обновить поля модели, которая ранее была получена из базы данных. Используйте поле id для понимания того, какую запись нужно обновлять!
Реализуйте метод save(), который решит - "новая" модель или нет и, в зависимости от этого, вызовет либо insert(), либо update().
Добавьте к моделям метод delete()
На базе реализованного вами кода сделайте простейшую (!) админ-панель новостей с функциями добавления, удаления и редактирования новости.

#3. Изоляция уровня представления
Повторите код, изученный на уроке. Выделите ту часть, которая управляет установкой и чтением произвольных свойств объекта в трейт. Не забудьте добавить реализацию метода __isset().
Добавьте к своим данным еще одну таблицу - авторы новостей (authors). В таблице новостей, соответственно, добавите поле author_id. Модифицируйте модель новостей следующим образом:
Если запрашивается поле ->author, то сначала проверяем поле ->author_id
Если оно не пусто - делаем запрос к таблице authors и возвращаем результат в виде объекта класса Author
Не забудьте снабдить модели соответствующим PHPDoc.
Измените шаблоны своего приложения, добавьте везде вывод авторов новостей
* Изучите интерфейс SPL ArrayAccess ( http://php.net/manual/ru/class.arrayaccess.php ) Придумайте применение этому поведению, реализуйте его в каком-либо классе своего приложения
* Изучите интерфейс Iterator и реализуйте его в своем приложении

#4. Контроллеры и фронт-контроллер
Напишите класс базового контроллера. Вынесите в него метод action($action).
Создайте контроллеры для клиентских страниц новостей (действия "все новости", "одна новость") и для админ-панели (действия "все новости", "редактирование", "сохранение")
Продумайте систему адресов. Например так: index.php?ctrl=CTRL&act=ACT, где СTRL - имя контроллера, ACT - имя экшна. Напишите фронт-контроллер в соответствии с этой системой адресов.
Подумайте - не сделать ли для админ-панели другую точку входа? А может быть другой базовый контроллер? Если решите, что это обоснованно - сделайте.
* Создайте систему ЧПУ. Адрес вида /XXX/YYY/ZZZ должен транслироваться в контроллер XXX\YYY (вложенность пространств имен неограничена) и действие ZZZ

#5. Исключения
Добавьте в свой проект класс исключений, возникающих при работе с базой данных. Придумайте - где их можно бросать? Как вариант - нет соединения с БД, ошибка в запросе.
Ловите исключения из пункта 1 во фронт-контроллере, поймав же, выдавайте пользователю красивую страницу с сообщением об ошибке.
Добавьте класс исключений, означающих "Ошибка 404 - не найдено". Бросайте такое исключение в ситуациях, когда вы не можете найти в базе запрашиваемую запись. Добавьте обработку исключений этого типа во фронт-контроллер.
Добавьте в модель новостей метод fill(array $data), который заполняет свойства модели данными из массива. Примените в этом методе паттерн "Мультиисключение".
* Добавьте в свой проект класс-логгер. Его задача - записывать в текстовый лог информацию об ошибках - когда и где возникла ошибка, какая. Логируйте исключения из пунктов 1 и 3.

#6. Современные стандарты PHP
Проверьте свой код на соответствие стандартам PSR-1 и PSR-2. При необходимости - исправьте.
Подключите с помощью composer на выбор к своему проекту одну из указанных библиотек:
psr/log
phpunit/php-timer
twig/twig
swiftmailer/swiftmailer
В зависимости от подключенной библиотеки реализуйте:
Собственный класс логгера на основе библиотечного интерфейса. Покажите его использование на примере отлова исключений с ошибками базы данных и исключений "404"
Счетчик времени и памяти для страниц сайта. Вывод значений счетчика в подвал страниц.
Переведите шаблоны страниц сайта (фронт, не админ-панель) на Twig
Организуйте отправку сообщения администратору сайта письма в случае возникновения проблем с подключением к базе данных
* Выделите в отдельный проект (отдельный репозиторий) библиотеку классов, реализующих концепцию "мультиисключение". Оформите ее как пакет composer.
NB. НЕ ДОБАВЛЯЙТЕ в git папку vendor! Под контролем git должны находиться только файлы composer.json и composer.lock

#7. "Новые" возможности PHP
Примените генератор в классе Db. У вас уже есть метод, называющийся как-то вроде query(), который использует fetchAll() из PDO. Сделайте метод-копию queryEach(), который будет генерировать запись за записью из ответа сервера базы данных, не делая fetchAll(), а построчно исполняя fetch(). Проверьте работу этого метода, использовав его в программе.
Создайте класс AdminDataTable. 
Его конструктор принимает на вход массив моделей (это будут строки таблицы) и массив функций (это будут столбцы)
Метод render() отображает таблицу следующим образом:
Для каждой записи (это строка) последовательно вызываются функции (каждая - это столбец), в них передается запись (модель)
То, что вернула функция - становится значением ячейки таблицы
Примените этот класс в своей админ-панели.